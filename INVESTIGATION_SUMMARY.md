# シミュレーションと代数計算の不一致調査まとめ

## 実施した検証

### 1. ネットワーク行列の検証 ✓

**検証内容:**
- CASE 4 (outward + center-only) のネットワーク行列が正しく生成されているか

**結果:**
```
W = [[0.99, 0.01, 0.00],
     [0.00, 1.00, 0.00],
     [0.00, 0.01, 0.99]]
```

- Agent 0 (左端): 99%自分、1%中心
- Agent 1 (中心): 100%自分
- Agent 2 (右端): 99%自分、1%中心

**結論:** ✓ 正しく実装されている（`test_network_matrix.py`で確認）

---

### 2. データフロー生成関数の検証 ✓

**検証内容:**
- `generate_data_flow_count` 関数が確率的に正しくサンプリングしているか
- 特にAgent 2が中心からコピーする確率が正しいか

**方法:** 10万回サンプリングして経験分布を確認

**結果:**
```
Agent 0: 中心からコピー 1.007% (期待値: 1.000%)
Agent 2: 中心からコピー 1.002% (期待値: 1.000%)
```

**結論:** ✓ 正しく動作している（`test_sampling_more.py`で確認）

---

### 3. local_k インデックスロジックの検証 ✓

**検証内容:**
- シミュレーションの更新ロジックで、各エージェントのデータスロットが正しくインデックスされているか

**結果:**
- N_i=1の場合: local_k は常に0
- N_i=2の場合: local_k は [0, 1] を正しくカバー

**結論:** ✓ 正しく実装されている（`analyze_local_k_logic.py`で確認）

---

### 4. 代数解析の対称性検証 ✓

**検証内容:**
- State 2 {{1},{2,3}} と State 4 {{3},{1,2}} の定常確率が等しいか

**結果:**
```
π_2 = 0.0438834810
π_4 = 0.0438834810
差: 0.00e+00
```

記号的にも数値的にも **完全に等しい**

**結論:** ✓ 代数解析は正しく対称的（`verify_state_symmetry.py`で確認）

---

### 5. シミュレーションの状態頻度分析

**検証内容:**
- 実際のシミュレーションで観測される状態の頻度を分析

**結果（66サンプル）:**
```
State 1 (全員同じ):     53回 (80.3%)  期待値: 86.4%
State 2 (Agent 0孤立):  5回  (7.6%)  期待値: 4.4%
State 3 (Agent 1孤立):  4回  (6.1%)  期待値: 4.3%
State 4 (Agent 2孤立):  4回  (6.1%)  期待値: 4.4%
State 5 (全員異なる):   0回  (0.0%)  期待値: 0.5%
```

**対称性:**
- State 2頻度: 7.6% (5回)
- State 4頻度: 6.1% (4回)
- 相対差: 20%
- 二項検定p値: 1.0000 → **統計的有意差なし**

**考察:**
- サンプル数が少なすぎる（State 2+4で合計9回のみ）
- サンプリング間隔が長すぎて短命な状態を捉えきれていない可能性

---

## 主要な発見

### ✓ 検証済み項目

1. **ネットワーク行列**: 正しい
2. **データフロー生成**: 正しい（10万回テスト）
3. **インデックスロジック**: 正しい
4. **代数解析の対称性**: 完全に対称
5. **シミュレーション実装**: 明らかなバグは発見されず

### ⚠ 未解決の問題

**ユーザー報告の非対称性:**
```
シミュレーション結果（ユーザー提供）:
  d_12 (Agent 0-1) = 0.09645
  d_13 (Agent 0-2) = 0.09510
  d_23 (Agent 1-2) = 0.09165

代数計算:
  d_12 = 0.09182
  d_13 = 0.09227
  d_23 = 0.09182
```

**問題点:**
1. **符号の不一致**: シミュレーションで d_12 > d_13 だが、代数では d_12 < d_13
2. **非対称性**: シミュレーションで d_12 ≠ d_23 だが、理論的には等しいはず

---

## 仮説

### 仮説1: サンプリング不足

**内容:**
- サンプリング間隔が長すぎて、短命な状態（State 2, 3, 4, 5）を十分に捉えられていない
- 特にState 2とState 4の頻度差を検出するには、より多くのサンプルが必要

**検証方法:**
- より長時間のシミュレーション（ユーザーが実行中）
- より短いサンプリング間隔

### 仮説2: 初期条件依存性

**内容:**
- シミュレーションが完全に定常状態に達していない可能性
- 初期状態からの影響が残っている

**検証方法:**
- より長いburn-in期間
- 異なる初期条件からの複数実行

### 仮説3: 未発見のバグ

**内容:**
- より微妙なバグが存在する可能性
  - 例: 更新順序の影響
  - 例: エッジケースの処理
  - 例: 乱数生成の問題

**検証方法:**
- ステップバイステップのトレース
- 小規模な完全検証
- 代替実装との比較

---

## 次のステップ

1. **長時間シミュレーション結果の解析**
   - ユーザーが実行中の10M stepシミュレーション結果を待つ
   - より多くのサンプルで統計的検定

2. **より頻繁なサンプリング**
   - save_intervalを短くして、より多くのスナップショットを取得
   - 短命な状態（State 2, 3, 4）を確実にキャプチャ

3. **独立検証**
   - 別のシミュレーション手法で確認
   - マルコフ連鎖の直接シミュレーション

4. **詳細なデバッグ**
   - 特定の遷移（State 1 → State 2 vs State 1 → State 4）を詳しく追跡
   - 各遷移の実際の確率を経験的に測定

---

## ファイル一覧

### 検証スクリプト

1. `test_network_matrix.py` - ネットワーク行列の検証
2. `test_data_flow_generation.py` - データフロー生成の検証
3. `test_sampling_more.py` - 10万回サンプリングテスト
4. `analyze_local_k_logic.py` - インデックスロジックの検証
5. `verify_state_symmetry.py` - 代数解析の対称性検証
6. `count_simulation_states.py` - シミュレーション状態頻度分析

### 解析スクリプト

7. `debug_simulation_states.py` - 状態の詳細解析
8. `analyze_only_long_simulation.py` - 長時間シミュレーション解析
9. `analyze_case4_simulation.py` - CASE 4結果解析
10. `compare_all_cases.py` - 複数ケースの比較

### 過去の調査

11. `debug_transition_probabilities.py` - 遷移確率の手動検証
12. `debug_all_transitions.py` - 全遷移行列の解析
13. `debug_reverse_transitions.py` - State 2↔3非対称性の解析

---

## 結論

**現時点での結論:**

1. ✓ コードの主要部分は正しく実装されている
2. ✓ 代数解析は理論的に正しい
3. ⚠ ユーザー報告の非対称性は**再現できていない**（サンプル不足の可能性）
4. ⏳ より長時間・高頻度のシミュレーション結果が必要

**暫定的な見解:**

代数解析とシミュレーションの不一致は、**サンプリング不足または収束不足**による可能性が高い。明らかなバグは発見されておらず、基本的な実装は正しいと判断される。

長時間シミュレーション（10M steps）の結果を待って、より確実な結論を出す必要がある。
